#ifndef {{project}}_SETTING_CALLBACKS_H
#define {{project}}_SETTING_CALLBACKS_H

/*
 * {{project}}_setting_callbacks.h
 * auto-generated from {{url}}
 * Date: {{date}}
 * Do not modify this file by hand. Check scripts/meta folder for generator files.
 */

extern "C"
{
  #include "libARSAL/ARSAL.h"
  #include "libARController/ARController.h"
}

#include "bebop_autonomy/autogenerated/callbacks_common.h"
#include "bebop_autonomy/BebopArdrone3Config.h"

namespace bebop_autonomy
{
namespace cb
{
{{#cpp_class}}

// {{cpp_class_comment}}
class {{cpp_class_name}} : public AbstractSetting
{
private:
{{#cpp_class_params}}
  {{cpp_class_param_type}} {{cpp_class_param_name}}_bebop_value_;
  bool {{cpp_class_param_name}}_bebop_sent_;
{{/cpp_class_params}}

public:
  {{cpp_class_name}}(ros::NodeHandle& priv_nh)
    : AbstractSetting({{cpp_class_dict_key}}, priv_nh)
{{#cpp_class_params}}
      , {{cpp_class_param_name}}_bebop_sent_(false)
{{/cpp_class_params}}
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

{{#cpp_class_params}}
    // This will likely fail for float or double values
    if ((config.{{cpp_class_param_name}} != {{cpp_class_param_name}}_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "{{cpp_class_param_name}} changed!");
      //{{cpp_class_param_name}}_bebop_value_ = config.{{cpp_class_param_name}};
      changed = true;
    }
    all_inited &= {{cpp_class_param_name}}_bebop_sent_;

{{/cpp_class_params}}
    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB", "Value of {{cpp_class_name}} was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Sending {{cpp_class_name}} changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->send{{cpp_class_name}}(bebop_ctrl_ptr_->aRDrone3
{{#cpp_class_params}}
        , {{{cpp_class_param_enum_cast}}}(config.{{cpp_class_param_name}})
{{/cpp_class_params}}
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "{{cpp_class_name}}::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
{{#cpp_class_params}}

    arg = NULL;
    HASH_FIND_STR (arguments, {{cpp_class_arg_key}}, arg);
    if (arg)
    {
      {{cpp_class_param_name}}_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for {{cpp_class_param_name}} recved: " << static_cast<{{cpp_class_param_type}}>(arg->value.{{cpp_class_param_sdk_type}}));
      {{cpp_class_param_name}}_bebop_value_ = static_cast<{{cpp_class_param_type}}>(arg->value.{{cpp_class_param_sdk_type}});

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if {{cpp_class_param_name}} exists in params ...");
      if (!priv_nh_.hasParam("{{cpp_class_param_name}}"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("{{cpp_class_param_name}}", static_cast<{{cpp_class_param_type}}>(arg->value.{{cpp_class_param_sdk_type}}));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << {{cpp_class_param_name}}_rosparam_value_);
      }
    }
{{/cpp_class_params}}
  }
};  // {{cpp_class_name}}
{{/cpp_class}}

}  // namespace cb
}  // namespace bebop_autonomy
#endif  // {{project}}_SETTING_CALLBACKS_H