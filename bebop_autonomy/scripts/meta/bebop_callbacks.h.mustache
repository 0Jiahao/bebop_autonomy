/* 
 * bebop_callbacks.h
 * auto-generated from {{url}}
 * Date: {{date}}
 * Generator: {{generator}} @ {{generator_git_hash}}
 * Do not modify this file by hand. Check scripts/meta folder for generator files.
 */

#ifndef BEBOPCALLBACKS_H
#define BEBOPCALLBACKS_H

extern "C"
{
  #include "libARSAL/ARSAL.h"
  #include "libARController/ARController.h"
  #include "libARDiscovery/ARDiscovery.h"
}

#include <ros/ros.h>
#include <boost/thread/mutex.hpp>
#include <boost/thread/unique_lock.hpp>

namespace bebop_autonomy
{

class CommandBase
{
protected:
  eARCONTROLLER_DICTIONARY_KEY cmd_key_;
  ARCONTROLLER_DICTIONARY_ARG_t* arg;
  mutable boost::mutex mutex_;
  ros::Publisher ros_pub_;

public:
  explicit CommandBase(eARCONTROLLER_DICTIONARY_KEY cmd_key)
    : cmd_key_(cmd_key), arg(NULL)
  {}

  virtual ~CommandBase()
  {}

  virtual void Update(const ARCONTROLLER_DICTIONARY_ARG_t* arg, const ros::Time& t) = 0;
};

{{#cpp_class}}

#include "bebop_autonomy_msgs/include/{{cpp_class_msg_type}}.h"

class {{cpp_class_name}} : public CommandBase
{
private:
  bebop_msgs::{{cpp_class_msg_type}} msg_ptr;

public:

  {{cpp_class_name}}(ros::NodeHandle& nh, const std::string& topic)
    : CommandBase({{key}})
  {
    ros_pub_ = nh.advertise<bebop_msgs::{{cpp_class_msg_type}}>(topic, {{queue_size}});
  }

  bebop_msgs::{{cpp_class_msg_type}} GetDataCstPtr() const
  {
    boost::unique_lock<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ros::Time& t)
  {
    if (arguments == NULL)
    {
      NODELET_WARN("{{cpp_class_name}}::Update() arguments is NULL");
      return;
    }

    boost::unique_lock<boost::mutex> lock(mutex_);
    msg_ptr.reset(new bebop_msgs::{{cpp_class_msg_type}}());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = {{{frame_id}}}

{{#cpp_class_arg}}

    arg = NULL;
    HASH_FIND_STR (arguments, {{cpp_class_arg_name}}, arg);
    if (arg)
    {
      msg_ptr->data = arg->value.{{cpp_class_arg_sdk_type}};
    }
{{/cpp_class_arg}}

    ros_pub_.publish(msg_ptr);
  }

};  // {{cpp_class_name}}

{{/cpp_class}}

}  // namespace bebop_autonomy
#endif  // BEBOPCALLBACKS_H