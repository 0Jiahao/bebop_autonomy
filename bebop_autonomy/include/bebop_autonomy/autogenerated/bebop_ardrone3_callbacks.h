#ifndef BEBOP_ARDrone3_CALLBACKS_H
#define BEBOP_ARDrone3_CALLBACKS_H

/*
 * bebop_ARDrone3_callbacks.h
 * auto-generated from https://raw.githubusercontent.com/Parrot-Developers/libARCommands/7e2f55fafcd45ba2380ca2574a08b7359c005f47/Xml/ARDrone3_commands.xml
 * Date: 2015-08-31 17:44:29.928022
 * Generator: generate.py @ 1291966
 * Do not modify this file by hand. Check scripts/meta folder for generator files.
 */

extern "C"
{
  #include "libARSAL/ARSAL.h"
  #include "libARController/ARController.h"
}

#include "bebop_autonomy/autogenerated/bebop_commands.h"

#include "bebop_autonomy_msgs/Ardrone3MediaRecordStatePictureStateChanged.h"
#include "bebop_autonomy_msgs/Ardrone3MediaRecordStateVideoStateChanged.h"
#include "bebop_autonomy_msgs/Ardrone3MediaRecordStatePictureStateChangedV2.h"
#include "bebop_autonomy_msgs/Ardrone3MediaRecordStateVideoStateChangedV2.h"
#include "bebop_autonomy_msgs/Ardrone3PilotingStateFlatTrimChanged.h"
#include "bebop_autonomy_msgs/Ardrone3PilotingStateFlyingStateChanged.h"
#include "bebop_autonomy_msgs/Ardrone3PilotingStateAlertStateChanged.h"
#include "bebop_autonomy_msgs/Ardrone3PilotingStateNavigateHomeStateChanged.h"
#include "bebop_autonomy_msgs/Ardrone3PilotingStatePositionChanged.h"
#include "bebop_autonomy_msgs/Ardrone3PilotingStateSpeedChanged.h"
#include "bebop_autonomy_msgs/Ardrone3PilotingStateAttitudeChanged.h"
#include "bebop_autonomy_msgs/Ardrone3PilotingStateAutoTakeOffModeChanged.h"
#include "bebop_autonomy_msgs/Ardrone3PilotingStateAltitudeChanged.h"
#include "bebop_autonomy_msgs/Ardrone3NetworkStateWifiScanListChanged.h"
#include "bebop_autonomy_msgs/Ardrone3NetworkStateAllWifiScanChanged.h"
#include "bebop_autonomy_msgs/Ardrone3NetworkStateWifiAuthChannelListChanged.h"
#include "bebop_autonomy_msgs/Ardrone3NetworkStateAllWifiAuthChannelChanged.h"
#include "bebop_autonomy_msgs/Ardrone3MediaStreamingStateVideoEnableChanged.h"
#include "bebop_autonomy_msgs/Ardrone3CameraStateOrientation.h"
#include "bebop_autonomy_msgs/Ardrone3AntiflickeringStateelectricFrequencyChanged.h"
#include "bebop_autonomy_msgs/Ardrone3AntiflickeringStatemodeChanged.h"
#include "bebop_autonomy_msgs/Ardrone3GPSStateNumberOfSatelliteChanged.h"
#include "bebop_autonomy_msgs/Ardrone3GPSStateHomeTypeAvailabilityChanged.h"
#include "bebop_autonomy_msgs/Ardrone3GPSStateHomeTypeChosenChanged.h"
#include "bebop_autonomy_msgs/Ardrone3PROStateFeatures.h"

namespace bebop_autonomy
{
namespace cb
{


class Ardrone3MediaRecordStatePictureStateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3MediaRecordStatePictureStateChanged::Ptr msg_ptr;

public:

  Ardrone3MediaRecordStatePictureStateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3MediaRecordStatePictureStateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3MediaRecordStatePictureStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3MediaRecordStatePictureStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3MediaRecordStatePictureStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID, arg);
    if (arg)
    {
      msg_ptr->mass_storage_id = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3MediaRecordStatePictureStateChanged


class Ardrone3MediaRecordStateVideoStateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3MediaRecordStateVideoStateChanged::Ptr msg_ptr;

public:

  Ardrone3MediaRecordStateVideoStateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3MediaRecordStateVideoStateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3MediaRecordStateVideoStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3MediaRecordStateVideoStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3MediaRecordStateVideoStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID, arg);
    if (arg)
    {
      msg_ptr->mass_storage_id = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3MediaRecordStateVideoStateChanged


class Ardrone3MediaRecordStatePictureStateChangedV2 : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3MediaRecordStatePictureStateChangedV2::Ptr msg_ptr;

public:

  Ardrone3MediaRecordStatePictureStateChangedV2(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3MediaRecordStatePictureStateChangedV2>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3MediaRecordStatePictureStateChangedV2::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3MediaRecordStatePictureStateChangedV2::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3MediaRecordStatePictureStateChangedV2());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR, arg);
    if (arg)
    {
      msg_ptr->error = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3MediaRecordStatePictureStateChangedV2


class Ardrone3MediaRecordStateVideoStateChangedV2 : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3MediaRecordStateVideoStateChangedV2::Ptr msg_ptr;

public:

  Ardrone3MediaRecordStateVideoStateChangedV2(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3MediaRecordStateVideoStateChangedV2>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3MediaRecordStateVideoStateChangedV2::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3MediaRecordStateVideoStateChangedV2::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3MediaRecordStateVideoStateChangedV2());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR, arg);
    if (arg)
    {
      msg_ptr->error = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3MediaRecordStateVideoStateChangedV2


class Ardrone3PilotingStateFlatTrimChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3PilotingStateFlatTrimChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateFlatTrimChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLATTRIMCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3PilotingStateFlatTrimChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3PilotingStateFlatTrimChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3PilotingStateFlatTrimChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3PilotingStateFlatTrimChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateFlatTrimChanged


class Ardrone3PilotingStateFlyingStateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3PilotingStateFlyingStateChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateFlyingStateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3PilotingStateFlyingStateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3PilotingStateFlyingStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3PilotingStateFlyingStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3PilotingStateFlyingStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateFlyingStateChanged


class Ardrone3PilotingStateAlertStateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3PilotingStateAlertStateChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateAlertStateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3PilotingStateAlertStateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3PilotingStateAlertStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3PilotingStateAlertStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3PilotingStateAlertStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateAlertStateChanged


class Ardrone3PilotingStateNavigateHomeStateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3PilotingStateNavigateHomeStateChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateNavigateHomeStateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3PilotingStateNavigateHomeStateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3PilotingStateNavigateHomeStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3PilotingStateNavigateHomeStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3PilotingStateNavigateHomeStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON, arg);
    if (arg)
    {
      msg_ptr->reason = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateNavigateHomeStateChanged


class Ardrone3PilotingStatePositionChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3PilotingStatePositionChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStatePositionChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3PilotingStatePositionChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3PilotingStatePositionChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3PilotingStatePositionChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3PilotingStatePositionChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LATITUDE, arg);
    if (arg)
    {
      msg_ptr->latitude = arg->value.Double;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LONGITUDE, arg);
    if (arg)
    {
      msg_ptr->longitude = arg->value.Double;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_ALTITUDE, arg);
    if (arg)
    {
      msg_ptr->altitude = arg->value.Double;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStatePositionChanged


class Ardrone3PilotingStateSpeedChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3PilotingStateSpeedChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateSpeedChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3PilotingStateSpeedChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3PilotingStateSpeedChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3PilotingStateSpeedChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3PilotingStateSpeedChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDX, arg);
    if (arg)
    {
      msg_ptr->speedX = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDY, arg);
    if (arg)
    {
      msg_ptr->speedY = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDZ, arg);
    if (arg)
    {
      msg_ptr->speedZ = arg->value.Float;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateSpeedChanged


class Ardrone3PilotingStateAttitudeChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3PilotingStateAttitudeChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateAttitudeChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3PilotingStateAttitudeChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3PilotingStateAttitudeChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3PilotingStateAttitudeChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3PilotingStateAttitudeChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_ROLL, arg);
    if (arg)
    {
      msg_ptr->roll = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_PITCH, arg);
    if (arg)
    {
      msg_ptr->pitch = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_YAW, arg);
    if (arg)
    {
      msg_ptr->yaw = arg->value.Float;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateAttitudeChanged


class Ardrone3PilotingStateAutoTakeOffModeChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3PilotingStateAutoTakeOffModeChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateAutoTakeOffModeChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3PilotingStateAutoTakeOffModeChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3PilotingStateAutoTakeOffModeChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3PilotingStateAutoTakeOffModeChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3PilotingStateAutoTakeOffModeChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateAutoTakeOffModeChanged


class Ardrone3PilotingStateAltitudeChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3PilotingStateAltitudeChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateAltitudeChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3PilotingStateAltitudeChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3PilotingStateAltitudeChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3PilotingStateAltitudeChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3PilotingStateAltitudeChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED_ALTITUDE, arg);
    if (arg)
    {
      msg_ptr->altitude = arg->value.Double;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateAltitudeChanged


class Ardrone3NetworkStateWifiScanListChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3NetworkStateWifiScanListChanged::Ptr msg_ptr;

public:

  Ardrone3NetworkStateWifiScanListChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3NetworkStateWifiScanListChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3NetworkStateWifiScanListChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3NetworkStateWifiScanListChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3NetworkStateWifiScanListChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_SSID, arg);
    if (arg)
    {
      msg_ptr->ssid = arg->value.String;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI, arg);
    if (arg)
    {
      msg_ptr->rssi = arg->value.I16;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND, arg);
    if (arg)
    {
      msg_ptr->band = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL, arg);
    if (arg)
    {
      msg_ptr->channel = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3NetworkStateWifiScanListChanged


class Ardrone3NetworkStateAllWifiScanChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3NetworkStateAllWifiScanChanged::Ptr msg_ptr;

public:

  Ardrone3NetworkStateAllWifiScanChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_ALLWIFISCANCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3NetworkStateAllWifiScanChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3NetworkStateAllWifiScanChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3NetworkStateAllWifiScanChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3NetworkStateAllWifiScanChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3NetworkStateAllWifiScanChanged


class Ardrone3NetworkStateWifiAuthChannelListChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3NetworkStateWifiAuthChannelListChanged::Ptr msg_ptr;

public:

  Ardrone3NetworkStateWifiAuthChannelListChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3NetworkStateWifiAuthChannelListChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3NetworkStateWifiAuthChannelListChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3NetworkStateWifiAuthChannelListChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3NetworkStateWifiAuthChannelListChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND, arg);
    if (arg)
    {
      msg_ptr->band = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL, arg);
    if (arg)
    {
      msg_ptr->channel = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT, arg);
    if (arg)
    {
      msg_ptr->in_or_out = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3NetworkStateWifiAuthChannelListChanged


class Ardrone3NetworkStateAllWifiAuthChannelChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3NetworkStateAllWifiAuthChannelChanged::Ptr msg_ptr;

public:

  Ardrone3NetworkStateAllWifiAuthChannelChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_ALLWIFIAUTHCHANNELCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3NetworkStateAllWifiAuthChannelChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3NetworkStateAllWifiAuthChannelChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3NetworkStateAllWifiAuthChannelChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3NetworkStateAllWifiAuthChannelChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3NetworkStateAllWifiAuthChannelChanged


class Ardrone3MediaStreamingStateVideoEnableChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3MediaStreamingStateVideoEnableChanged::Ptr msg_ptr;

public:

  Ardrone3MediaStreamingStateVideoEnableChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3MediaStreamingStateVideoEnableChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3MediaStreamingStateVideoEnableChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3MediaStreamingStateVideoEnableChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3MediaStreamingStateVideoEnableChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED, arg);
    if (arg)
    {
      msg_ptr->enabled = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3MediaStreamingStateVideoEnableChanged


class Ardrone3CameraStateOrientation : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3CameraStateOrientation::Ptr msg_ptr;

public:

  Ardrone3CameraStateOrientation(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3CameraStateOrientation>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3CameraStateOrientation::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3CameraStateOrientation::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3CameraStateOrientation());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_TILT, arg);
    if (arg)
    {
      msg_ptr->tilt = arg->value.I8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_PAN, arg);
    if (arg)
    {
      msg_ptr->pan = arg->value.I8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3CameraStateOrientation


class Ardrone3AntiflickeringStateelectricFrequencyChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3AntiflickeringStateelectricFrequencyChanged::Ptr msg_ptr;

public:

  Ardrone3AntiflickeringStateelectricFrequencyChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3AntiflickeringStateelectricFrequencyChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3AntiflickeringStateelectricFrequencyChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3AntiflickeringStateelectricFrequencyChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3AntiflickeringStateelectricFrequencyChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY, arg);
    if (arg)
    {
      msg_ptr->frequency = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3AntiflickeringStateelectricFrequencyChanged


class Ardrone3AntiflickeringStatemodeChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3AntiflickeringStatemodeChanged::Ptr msg_ptr;

public:

  Ardrone3AntiflickeringStatemodeChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3AntiflickeringStatemodeChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3AntiflickeringStatemodeChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3AntiflickeringStatemodeChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3AntiflickeringStatemodeChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE, arg);
    if (arg)
    {
      msg_ptr->mode = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3AntiflickeringStatemodeChanged


class Ardrone3GPSStateNumberOfSatelliteChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3GPSStateNumberOfSatelliteChanged::Ptr msg_ptr;

public:

  Ardrone3GPSStateNumberOfSatelliteChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3GPSStateNumberOfSatelliteChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3GPSStateNumberOfSatelliteChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3GPSStateNumberOfSatelliteChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3GPSStateNumberOfSatelliteChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED_NUMBEROFSATELLITE, arg);
    if (arg)
    {
      msg_ptr->numberOfSatellite = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3GPSStateNumberOfSatelliteChanged


class Ardrone3GPSStateHomeTypeAvailabilityChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3GPSStateHomeTypeAvailabilityChanged::Ptr msg_ptr;

public:

  Ardrone3GPSStateHomeTypeAvailabilityChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3GPSStateHomeTypeAvailabilityChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3GPSStateHomeTypeAvailabilityChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3GPSStateHomeTypeAvailabilityChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3GPSStateHomeTypeAvailabilityChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE, arg);
    if (arg)
    {
      msg_ptr->type = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_AVAILABLE, arg);
    if (arg)
    {
      msg_ptr->available = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3GPSStateHomeTypeAvailabilityChanged


class Ardrone3GPSStateHomeTypeChosenChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3GPSStateHomeTypeChosenChanged::Ptr msg_ptr;

public:

  Ardrone3GPSStateHomeTypeChosenChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3GPSStateHomeTypeChosenChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3GPSStateHomeTypeChosenChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3GPSStateHomeTypeChosenChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3GPSStateHomeTypeChosenChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE, arg);
    if (arg)
    {
      msg_ptr->type = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3GPSStateHomeTypeChosenChanged


class Ardrone3PROStateFeatures : public CommandBase
{
private:
  ::bebop_autonomy_msgs::Ardrone3PROStateFeatures::Ptr msg_ptr;

public:

  Ardrone3PROStateFeatures(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::Ardrone3PROStateFeatures>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::Ardrone3PROStateFeatures::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("Ardrone3PROStateFeatures::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::Ardrone3PROStateFeatures());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES_FEATURES, arg);
    if (arg)
    {
      msg_ptr->features = arg->value.U64;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PROStateFeatures


}  // namespace cb
}  // namespace bebop_autonomy
#endif  // BEBOP_ARDrone3_CALLBACKS_H