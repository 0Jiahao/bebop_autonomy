#ifndef BEBOP_common_CALLBACKS_H
#define BEBOP_common_CALLBACKS_H

/*
 * bebop_common_callbacks.h
 * auto-generated from https://raw.githubusercontent.com/Parrot-Developers/libARCommands/7e2f55fafcd45ba2380ca2574a08b7359c005f47/Xml/common_commands.xml
 * Date: 2015-08-31 17:44:29.412157
 * Generator: generate.py @ 1291966
 * Do not modify this file by hand. Check scripts/meta folder for generator files.
 */

extern "C"
{
  #include "libARSAL/ARSAL.h"
  #include "libARController/ARController.h"
}

#include "bebop_autonomy/autogenerated/bebop_commands.h"

#include "bebop_autonomy_msgs/CommonCommonStateAllStatesChanged.h"
#include "bebop_autonomy_msgs/CommonCommonStateBatteryStateChanged.h"
#include "bebop_autonomy_msgs/CommonCommonStateMassStorageStateListChanged.h"
#include "bebop_autonomy_msgs/CommonCommonStateMassStorageInfoStateListChanged.h"
#include "bebop_autonomy_msgs/CommonCommonStateCurrentDateChanged.h"
#include "bebop_autonomy_msgs/CommonCommonStateCurrentTimeChanged.h"
#include "bebop_autonomy_msgs/CommonCommonStateMassStorageInfoRemainingListChanged.h"
#include "bebop_autonomy_msgs/CommonCommonStateWifiSignalChanged.h"
#include "bebop_autonomy_msgs/CommonCommonStateSensorsStatesListChanged.h"
#include "bebop_autonomy_msgs/CommonCommonStateProductModel.h"
#include "bebop_autonomy_msgs/CommonCommonStateCountryListKnown.h"
#include "bebop_autonomy_msgs/CommonOverHeatStateOverHeatChanged.h"
#include "bebop_autonomy_msgs/CommonOverHeatStateOverHeatRegulationChanged.h"
#include "bebop_autonomy_msgs/CommonControllerStateisPilotingChanged.h"
#include "bebop_autonomy_msgs/CommonMavlinkStateMavlinkFilePlayingStateChanged.h"
#include "bebop_autonomy_msgs/CommonMavlinkStateMavlinkPlayErrorStateChanged.h"
#include "bebop_autonomy_msgs/CommonCalibrationStateMagnetoCalibrationStateChanged.h"
#include "bebop_autonomy_msgs/CommonCalibrationStateMagnetoCalibrationRequiredState.h"
#include "bebop_autonomy_msgs/CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChanged.h"
#include "bebop_autonomy_msgs/CommonCalibrationStateMagnetoCalibrationStartedChanged.h"
#include "bebop_autonomy_msgs/CommonFlightPlanStateAvailabilityStateChanged.h"
#include "bebop_autonomy_msgs/CommonFlightPlanStateComponentStateListChanged.h"
#include "bebop_autonomy_msgs/CommonARLibsVersionsStateControllerLibARCommandsVersion.h"
#include "bebop_autonomy_msgs/CommonARLibsVersionsStateSkyControllerLibARCommandsVersion.h"
#include "bebop_autonomy_msgs/CommonARLibsVersionsStateDeviceLibARCommandsVersion.h"
#include "bebop_autonomy_msgs/CommonAudioStateAudioStreamingRunning.h"
#include "bebop_autonomy_msgs/CommonHeadlightsStateintensityChanged.h"
#include "bebop_autonomy_msgs/CommonAnimationsStateList.h"
#include "bebop_autonomy_msgs/CommonAccessoryStateSupportedAccessoriesListChanged.h"
#include "bebop_autonomy_msgs/CommonAccessoryStateAccessoryConfigChanged.h"
#include "bebop_autonomy_msgs/CommonAccessoryStateAccessoryConfigModificationEnabled.h"
#include "bebop_autonomy_msgs/CommonChargerStateMaxChargeRateChanged.h"
#include "bebop_autonomy_msgs/CommonChargerStateCurrentChargeStateChanged.h"
#include "bebop_autonomy_msgs/CommonChargerStateLastChargeRateChanged.h"
#include "bebop_autonomy_msgs/CommonChargerStateChargingInfo.h"

namespace bebop_autonomy
{
namespace cb
{


class CommonCommonStateAllStatesChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCommonStateAllStatesChanged::Ptr msg_ptr;

public:

  CommonCommonStateAllStatesChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_ALLSTATESCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCommonStateAllStatesChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCommonStateAllStatesChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCommonStateAllStatesChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCommonStateAllStatesChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    ros_pub_.publish(msg_ptr);
  }

};  // CommonCommonStateAllStatesChanged


class CommonCommonStateBatteryStateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCommonStateBatteryStateChanged::Ptr msg_ptr;

public:

  CommonCommonStateBatteryStateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_BATTERYSTATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCommonStateBatteryStateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCommonStateBatteryStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCommonStateBatteryStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCommonStateBatteryStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_BATTERYSTATECHANGED_PERCENT, arg);
    if (arg)
    {
      msg_ptr->percent = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonCommonStateBatteryStateChanged


class CommonCommonStateMassStorageStateListChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCommonStateMassStorageStateListChanged::Ptr msg_ptr;

public:

  CommonCommonStateMassStorageStateListChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCommonStateMassStorageStateListChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCommonStateMassStorageStateListChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCommonStateMassStorageStateListChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCommonStateMassStorageStateListChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED_MASS_STORAGE_ID, arg);
    if (arg)
    {
      msg_ptr->mass_storage_id = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED_NAME, arg);
    if (arg)
    {
      msg_ptr->name = arg->value.String;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonCommonStateMassStorageStateListChanged


class CommonCommonStateMassStorageInfoStateListChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCommonStateMassStorageInfoStateListChanged::Ptr msg_ptr;

public:

  CommonCommonStateMassStorageInfoStateListChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCommonStateMassStorageInfoStateListChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCommonStateMassStorageInfoStateListChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCommonStateMassStorageInfoStateListChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCommonStateMassStorageInfoStateListChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_MASS_STORAGE_ID, arg);
    if (arg)
    {
      msg_ptr->mass_storage_id = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_SIZE, arg);
    if (arg)
    {
      msg_ptr->size = arg->value.U32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_USED_SIZE, arg);
    if (arg)
    {
      msg_ptr->used_size = arg->value.U32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_PLUGGED, arg);
    if (arg)
    {
      msg_ptr->plugged = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_FULL, arg);
    if (arg)
    {
      msg_ptr->full = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_INTERNAL, arg);
    if (arg)
    {
      msg_ptr->internal = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonCommonStateMassStorageInfoStateListChanged


class CommonCommonStateCurrentDateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCommonStateCurrentDateChanged::Ptr msg_ptr;

public:

  CommonCommonStateCurrentDateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTDATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCommonStateCurrentDateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCommonStateCurrentDateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCommonStateCurrentDateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCommonStateCurrentDateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTDATECHANGED_DATE, arg);
    if (arg)
    {
      msg_ptr->date = arg->value.String;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonCommonStateCurrentDateChanged


class CommonCommonStateCurrentTimeChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCommonStateCurrentTimeChanged::Ptr msg_ptr;

public:

  CommonCommonStateCurrentTimeChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTTIMECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCommonStateCurrentTimeChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCommonStateCurrentTimeChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCommonStateCurrentTimeChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCommonStateCurrentTimeChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTTIMECHANGED_TIME, arg);
    if (arg)
    {
      msg_ptr->time = arg->value.String;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonCommonStateCurrentTimeChanged


class CommonCommonStateMassStorageInfoRemainingListChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCommonStateMassStorageInfoRemainingListChanged::Ptr msg_ptr;

public:

  CommonCommonStateMassStorageInfoRemainingListChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCommonStateMassStorageInfoRemainingListChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCommonStateMassStorageInfoRemainingListChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCommonStateMassStorageInfoRemainingListChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCommonStateMassStorageInfoRemainingListChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_FREE_SPACE, arg);
    if (arg)
    {
      msg_ptr->free_space = arg->value.U32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_REC_TIME, arg);
    if (arg)
    {
      msg_ptr->rec_time = arg->value.U16;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_PHOTO_REMAINING, arg);
    if (arg)
    {
      msg_ptr->photo_remaining = arg->value.U32;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonCommonStateMassStorageInfoRemainingListChanged


class CommonCommonStateWifiSignalChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCommonStateWifiSignalChanged::Ptr msg_ptr;

public:

  CommonCommonStateWifiSignalChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_WIFISIGNALCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCommonStateWifiSignalChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCommonStateWifiSignalChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCommonStateWifiSignalChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCommonStateWifiSignalChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_WIFISIGNALCHANGED_RSSI, arg);
    if (arg)
    {
      msg_ptr->rssi = arg->value.I16;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonCommonStateWifiSignalChanged


class CommonCommonStateSensorsStatesListChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCommonStateSensorsStatesListChanged::Ptr msg_ptr;

public:

  CommonCommonStateSensorsStatesListChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCommonStateSensorsStatesListChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCommonStateSensorsStatesListChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCommonStateSensorsStatesListChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCommonStateSensorsStatesListChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME, arg);
    if (arg)
    {
      msg_ptr->sensorName = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORSTATE, arg);
    if (arg)
    {
      msg_ptr->sensorState = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonCommonStateSensorsStatesListChanged


class CommonCommonStateProductModel : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCommonStateProductModel::Ptr msg_ptr;

public:

  CommonCommonStateProductModel(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_PRODUCTMODEL)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCommonStateProductModel>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCommonStateProductModel::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCommonStateProductModel::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCommonStateProductModel());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL, arg);
    if (arg)
    {
      msg_ptr->model = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonCommonStateProductModel


class CommonCommonStateCountryListKnown : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCommonStateCountryListKnown::Ptr msg_ptr;

public:

  CommonCommonStateCountryListKnown(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_COUNTRYLISTKNOWN)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCommonStateCountryListKnown>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCommonStateCountryListKnown::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCommonStateCountryListKnown::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCommonStateCountryListKnown());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_COUNTRYLISTKNOWN_COUNTRYCODES, arg);
    if (arg)
    {
      msg_ptr->countryCodes = arg->value.String;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonCommonStateCountryListKnown


class CommonOverHeatStateOverHeatChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonOverHeatStateOverHeatChanged::Ptr msg_ptr;

public:

  CommonOverHeatStateOverHeatChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonOverHeatStateOverHeatChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonOverHeatStateOverHeatChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonOverHeatStateOverHeatChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonOverHeatStateOverHeatChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    ros_pub_.publish(msg_ptr);
  }

};  // CommonOverHeatStateOverHeatChanged


class CommonOverHeatStateOverHeatRegulationChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonOverHeatStateOverHeatRegulationChanged::Ptr msg_ptr;

public:

  CommonOverHeatStateOverHeatRegulationChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATREGULATIONCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonOverHeatStateOverHeatRegulationChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonOverHeatStateOverHeatRegulationChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonOverHeatStateOverHeatRegulationChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonOverHeatStateOverHeatRegulationChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATREGULATIONCHANGED_REGULATIONTYPE, arg);
    if (arg)
    {
      msg_ptr->regulationType = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonOverHeatStateOverHeatRegulationChanged


class CommonControllerStateisPilotingChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonControllerStateisPilotingChanged::Ptr msg_ptr;

public:

  CommonControllerStateisPilotingChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_CONTROLLERSTATE_ISPILOTINGCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonControllerStateisPilotingChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonControllerStateisPilotingChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonControllerStateisPilotingChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonControllerStateisPilotingChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CONTROLLERSTATE_ISPILOTINGCHANGED_PILOTING, arg);
    if (arg)
    {
      msg_ptr->piloting = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonControllerStateisPilotingChanged


class CommonMavlinkStateMavlinkFilePlayingStateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonMavlinkStateMavlinkFilePlayingStateChanged::Ptr msg_ptr;

public:

  CommonMavlinkStateMavlinkFilePlayingStateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonMavlinkStateMavlinkFilePlayingStateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonMavlinkStateMavlinkFilePlayingStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonMavlinkStateMavlinkFilePlayingStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonMavlinkStateMavlinkFilePlayingStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_FILEPATH, arg);
    if (arg)
    {
      msg_ptr->filepath = arg->value.String;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE, arg);
    if (arg)
    {
      msg_ptr->type = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonMavlinkStateMavlinkFilePlayingStateChanged


class CommonMavlinkStateMavlinkPlayErrorStateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonMavlinkStateMavlinkPlayErrorStateChanged::Ptr msg_ptr;

public:

  CommonMavlinkStateMavlinkPlayErrorStateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonMavlinkStateMavlinkPlayErrorStateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonMavlinkStateMavlinkPlayErrorStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonMavlinkStateMavlinkPlayErrorStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonMavlinkStateMavlinkPlayErrorStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR, arg);
    if (arg)
    {
      msg_ptr->error = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonMavlinkStateMavlinkPlayErrorStateChanged


class CommonCalibrationStateMagnetoCalibrationStateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationStateChanged::Ptr msg_ptr;

public:

  CommonCalibrationStateMagnetoCalibrationStateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationStateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCalibrationStateMagnetoCalibrationStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_XAXISCALIBRATION, arg);
    if (arg)
    {
      msg_ptr->xAxisCalibration = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_YAXISCALIBRATION, arg);
    if (arg)
    {
      msg_ptr->yAxisCalibration = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_ZAXISCALIBRATION, arg);
    if (arg)
    {
      msg_ptr->zAxisCalibration = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_CALIBRATIONFAILED, arg);
    if (arg)
    {
      msg_ptr->calibrationFailed = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonCalibrationStateMagnetoCalibrationStateChanged


class CommonCalibrationStateMagnetoCalibrationRequiredState : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationRequiredState::Ptr msg_ptr;

public:

  CommonCalibrationStateMagnetoCalibrationRequiredState(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONREQUIREDSTATE)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationRequiredState>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationRequiredState::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCalibrationStateMagnetoCalibrationRequiredState::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationRequiredState());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONREQUIREDSTATE_REQUIRED, arg);
    if (arg)
    {
      msg_ptr->required = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonCalibrationStateMagnetoCalibrationRequiredState


class CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChanged::Ptr msg_ptr;

public:

  CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS, arg);
    if (arg)
    {
      msg_ptr->axis = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChanged


class CommonCalibrationStateMagnetoCalibrationStartedChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationStartedChanged::Ptr msg_ptr;

public:

  CommonCalibrationStateMagnetoCalibrationStartedChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTARTEDCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationStartedChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationStartedChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonCalibrationStateMagnetoCalibrationStartedChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonCalibrationStateMagnetoCalibrationStartedChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTARTEDCHANGED_STARTED, arg);
    if (arg)
    {
      msg_ptr->started = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonCalibrationStateMagnetoCalibrationStartedChanged


class CommonFlightPlanStateAvailabilityStateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonFlightPlanStateAvailabilityStateChanged::Ptr msg_ptr;

public:

  CommonFlightPlanStateAvailabilityStateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_AVAILABILITYSTATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonFlightPlanStateAvailabilityStateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonFlightPlanStateAvailabilityStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonFlightPlanStateAvailabilityStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonFlightPlanStateAvailabilityStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_AVAILABILITYSTATECHANGED_AVAILABILITYSTATE, arg);
    if (arg)
    {
      msg_ptr->AvailabilityState = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonFlightPlanStateAvailabilityStateChanged


class CommonFlightPlanStateComponentStateListChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonFlightPlanStateComponentStateListChanged::Ptr msg_ptr;

public:

  CommonFlightPlanStateComponentStateListChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonFlightPlanStateComponentStateListChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonFlightPlanStateComponentStateListChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonFlightPlanStateComponentStateListChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonFlightPlanStateComponentStateListChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT, arg);
    if (arg)
    {
      msg_ptr->component = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->State = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonFlightPlanStateComponentStateListChanged


class CommonARLibsVersionsStateControllerLibARCommandsVersion : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonARLibsVersionsStateControllerLibARCommandsVersion::Ptr msg_ptr;

public:

  CommonARLibsVersionsStateControllerLibARCommandsVersion(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_CONTROLLERLIBARCOMMANDSVERSION)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonARLibsVersionsStateControllerLibARCommandsVersion>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonARLibsVersionsStateControllerLibARCommandsVersion::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonARLibsVersionsStateControllerLibARCommandsVersion::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonARLibsVersionsStateControllerLibARCommandsVersion());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_CONTROLLERLIBARCOMMANDSVERSION_VERSION, arg);
    if (arg)
    {
      msg_ptr->version = arg->value.String;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonARLibsVersionsStateControllerLibARCommandsVersion


class CommonARLibsVersionsStateSkyControllerLibARCommandsVersion : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonARLibsVersionsStateSkyControllerLibARCommandsVersion::Ptr msg_ptr;

public:

  CommonARLibsVersionsStateSkyControllerLibARCommandsVersion(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_SKYCONTROLLERLIBARCOMMANDSVERSION)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonARLibsVersionsStateSkyControllerLibARCommandsVersion>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonARLibsVersionsStateSkyControllerLibARCommandsVersion::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonARLibsVersionsStateSkyControllerLibARCommandsVersion::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonARLibsVersionsStateSkyControllerLibARCommandsVersion());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_SKYCONTROLLERLIBARCOMMANDSVERSION_VERSION, arg);
    if (arg)
    {
      msg_ptr->version = arg->value.String;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonARLibsVersionsStateSkyControllerLibARCommandsVersion


class CommonARLibsVersionsStateDeviceLibARCommandsVersion : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonARLibsVersionsStateDeviceLibARCommandsVersion::Ptr msg_ptr;

public:

  CommonARLibsVersionsStateDeviceLibARCommandsVersion(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_DEVICELIBARCOMMANDSVERSION)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonARLibsVersionsStateDeviceLibARCommandsVersion>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonARLibsVersionsStateDeviceLibARCommandsVersion::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonARLibsVersionsStateDeviceLibARCommandsVersion::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonARLibsVersionsStateDeviceLibARCommandsVersion());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_DEVICELIBARCOMMANDSVERSION_VERSION, arg);
    if (arg)
    {
      msg_ptr->version = arg->value.String;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonARLibsVersionsStateDeviceLibARCommandsVersion


class CommonAudioStateAudioStreamingRunning : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonAudioStateAudioStreamingRunning::Ptr msg_ptr;

public:

  CommonAudioStateAudioStreamingRunning(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_AUDIOSTATE_AUDIOSTREAMINGRUNNING)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonAudioStateAudioStreamingRunning>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonAudioStateAudioStreamingRunning::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonAudioStateAudioStreamingRunning::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonAudioStateAudioStreamingRunning());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_AUDIOSTATE_AUDIOSTREAMINGRUNNING_RUNNING, arg);
    if (arg)
    {
      msg_ptr->running = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonAudioStateAudioStreamingRunning


class CommonHeadlightsStateintensityChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonHeadlightsStateintensityChanged::Ptr msg_ptr;

public:

  CommonHeadlightsStateintensityChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_HEADLIGHTSSTATE_INTENSITYCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonHeadlightsStateintensityChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonHeadlightsStateintensityChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonHeadlightsStateintensityChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonHeadlightsStateintensityChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_HEADLIGHTSSTATE_INTENSITYCHANGED_LEFT, arg);
    if (arg)
    {
      msg_ptr->left = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_HEADLIGHTSSTATE_INTENSITYCHANGED_RIGHT, arg);
    if (arg)
    {
      msg_ptr->right = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonHeadlightsStateintensityChanged


class CommonAnimationsStateList : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonAnimationsStateList::Ptr msg_ptr;

public:

  CommonAnimationsStateList(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonAnimationsStateList>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonAnimationsStateList::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonAnimationsStateList::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonAnimationsStateList());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_ANIM, arg);
    if (arg)
    {
      msg_ptr->anim = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_ERROR, arg);
    if (arg)
    {
      msg_ptr->error = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonAnimationsStateList


class CommonAccessoryStateSupportedAccessoriesListChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonAccessoryStateSupportedAccessoriesListChanged::Ptr msg_ptr;

public:

  CommonAccessoryStateSupportedAccessoriesListChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonAccessoryStateSupportedAccessoriesListChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonAccessoryStateSupportedAccessoriesListChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonAccessoryStateSupportedAccessoriesListChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonAccessoryStateSupportedAccessoriesListChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY, arg);
    if (arg)
    {
      msg_ptr->accessory = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonAccessoryStateSupportedAccessoriesListChanged


class CommonAccessoryStateAccessoryConfigChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonAccessoryStateAccessoryConfigChanged::Ptr msg_ptr;

public:

  CommonAccessoryStateAccessoryConfigChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonAccessoryStateAccessoryConfigChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonAccessoryStateAccessoryConfigChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonAccessoryStateAccessoryConfigChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonAccessoryStateAccessoryConfigChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY, arg);
    if (arg)
    {
      msg_ptr->newAccessory = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR, arg);
    if (arg)
    {
      msg_ptr->error = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonAccessoryStateAccessoryConfigChanged


class CommonAccessoryStateAccessoryConfigModificationEnabled : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonAccessoryStateAccessoryConfigModificationEnabled::Ptr msg_ptr;

public:

  CommonAccessoryStateAccessoryConfigModificationEnabled(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGMODIFICATIONENABLED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonAccessoryStateAccessoryConfigModificationEnabled>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonAccessoryStateAccessoryConfigModificationEnabled::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonAccessoryStateAccessoryConfigModificationEnabled::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonAccessoryStateAccessoryConfigModificationEnabled());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGMODIFICATIONENABLED_ENABLED, arg);
    if (arg)
    {
      msg_ptr->enabled = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonAccessoryStateAccessoryConfigModificationEnabled


class CommonChargerStateMaxChargeRateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonChargerStateMaxChargeRateChanged::Ptr msg_ptr;

public:

  CommonChargerStateMaxChargeRateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonChargerStateMaxChargeRateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonChargerStateMaxChargeRateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonChargerStateMaxChargeRateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonChargerStateMaxChargeRateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE, arg);
    if (arg)
    {
      msg_ptr->rate = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonChargerStateMaxChargeRateChanged


class CommonChargerStateCurrentChargeStateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonChargerStateCurrentChargeStateChanged::Ptr msg_ptr;

public:

  CommonChargerStateCurrentChargeStateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonChargerStateCurrentChargeStateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonChargerStateCurrentChargeStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonChargerStateCurrentChargeStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonChargerStateCurrentChargeStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS, arg);
    if (arg)
    {
      msg_ptr->status = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE, arg);
    if (arg)
    {
      msg_ptr->phase = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonChargerStateCurrentChargeStateChanged


class CommonChargerStateLastChargeRateChanged : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonChargerStateLastChargeRateChanged::Ptr msg_ptr;

public:

  CommonChargerStateLastChargeRateChanged(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonChargerStateLastChargeRateChanged>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonChargerStateLastChargeRateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonChargerStateLastChargeRateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonChargerStateLastChargeRateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE, arg);
    if (arg)
    {
      msg_ptr->rate = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonChargerStateLastChargeRateChanged


class CommonChargerStateChargingInfo : public CommandBase
{
private:
  ::bebop_autonomy_msgs::CommonChargerStateChargingInfo::Ptr msg_ptr;

public:

  CommonChargerStateChargingInfo(::ros::NodeHandle& nh, const ::std::string& topic)
    : CommandBase(ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO)
  {
    ros_pub_ = nh.advertise<bebop_autonomy_msgs::CommonChargerStateChargingInfo>(topic, 10, true);
  }

  ::bebop_autonomy_msgs::CommonChargerStateChargingInfo::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ROS_WARN("CommonChargerStateChargingInfo::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_autonomy_msgs::CommonChargerStateChargingInfo());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE, arg);
    if (arg)
    {
      msg_ptr->phase = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_RATE, arg);
    if (arg)
    {
      msg_ptr->rate = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_INTENSITY, arg);
    if (arg)
    {
      msg_ptr->intensity = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_FULLCHARGINGTIME, arg);
    if (arg)
    {
      msg_ptr->fullChargingTime = arg->value.U8;
    }

    ros_pub_.publish(msg_ptr);
  }

};  // CommonChargerStateChargingInfo


}  // namespace cb
}  // namespace bebop_autonomy
#endif  // BEBOP_common_CALLBACKS_H