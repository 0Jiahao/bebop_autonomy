#ifndef Ardrone3_SETTING_CALLBACKS_H
#define Ardrone3_SETTING_CALLBACKS_H

/*
 * Ardrone3_setting_callbacks.h
 * auto-generated from https://raw.githubusercontent.com/Parrot-Developers/libARCommands/7e2f55fafcd45ba2380ca2574a08b7359c005f47/Xml/ARDrone3_commands.xml
 * Date: 2015-09-02
 * Do not modify this file by hand. Check scripts/meta folder for generator files.
 */

extern "C"
{
  #include "libARSAL/ARSAL.h"
  #include "libARController/ARController.h"
}

#include "bebop_autonomy/autogenerated/callbacks_common.h"

namespace bebop_autonomy
{
namespace cb
{


// 
class PilotingSettingsMaxAltitude : public AbstractSetting
{
private:
double PilotingSettingsMaxAltitudeCurrent_;

public:

  PilotingSettingsMaxAltitude()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    bool changed = false;
    ::boost::lock_guard<boost::mutex> lock(mutex_);

    // This will likely fail for float or double values
    if (config.PilotingSettingsMaxAltitudeCurrent != PilotingSettingsMaxAltitudeCurrent_)
    {
      PilotingSettingsMaxAltitudeCurrent_ = config.PilotingSettingsMaxAltitudeCurrent;
      changed = true;
    }


    if (changed)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Sending PilotingSettingsMaxAltitude changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsMaxAltitude(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsMaxAltitudeCurrent)
      );
    }

  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "PilotingSettingsMaxAltitude::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT, arg);
    if (arg)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsMaxAltitudeCurrent exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsMaxAltitudeCurrent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsMaxAltitudeCurrent", arg->value.Float);
        PilotingSettingsMaxAltitudeCurrent_ = static_cast<double>(arg->value.Float);
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
      }
    }

  }

};  // PilotingSettingsMaxAltitude


// 
class PilotingSettingsMaxTilt : public AbstractSetting
{
private:
double PilotingSettingsMaxTiltCurrent_;

public:

  PilotingSettingsMaxTilt()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    bool changed = false;
    ::boost::lock_guard<boost::mutex> lock(mutex_);

    // This will likely fail for float or double values
    if (config.PilotingSettingsMaxTiltCurrent != PilotingSettingsMaxTiltCurrent_)
    {
      PilotingSettingsMaxTiltCurrent_ = config.PilotingSettingsMaxTiltCurrent;
      changed = true;
    }


    if (changed)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Sending PilotingSettingsMaxTilt changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsMaxTilt(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsMaxTiltCurrent)
      );
    }

  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "PilotingSettingsMaxTilt::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT, arg);
    if (arg)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsMaxTiltCurrent exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsMaxTiltCurrent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsMaxTiltCurrent", arg->value.Float);
        PilotingSettingsMaxTiltCurrent_ = static_cast<double>(arg->value.Float);
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
      }
    }

  }

};  // PilotingSettingsMaxTilt


// 
class PilotingSettingsAbsolutControl : public AbstractSetting
{
private:
int32_t PilotingSettingsAbsolutControlOn_;

public:

  PilotingSettingsAbsolutControl()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    bool changed = false;
    ::boost::lock_guard<boost::mutex> lock(mutex_);

    // This will likely fail for float or double values
    if (config.PilotingSettingsAbsolutControlOn != PilotingSettingsAbsolutControlOn_)
    {
      PilotingSettingsAbsolutControlOn_ = config.PilotingSettingsAbsolutControlOn;
      changed = true;
    }


    if (changed)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Sending PilotingSettingsAbsolutControl changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsAbsolutControl(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsAbsolutControlOn)
      );
    }

  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "PilotingSettingsAbsolutControl::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED_ON, arg);
    if (arg)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsAbsolutControlOn exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsAbsolutControlOn"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsAbsolutControlOn", arg->value.U8);
        PilotingSettingsAbsolutControlOn_ = static_cast<int32_t>(arg->value.U8);
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
      }
    }

  }

};  // PilotingSettingsAbsolutControl


// 
class PilotingSettingsMaxDistance : public AbstractSetting
{
private:
double PilotingSettingsMaxDistanceValue_;

public:

  PilotingSettingsMaxDistance()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    bool changed = false;
    ::boost::lock_guard<boost::mutex> lock(mutex_);

    // This will likely fail for float or double values
    if (config.PilotingSettingsMaxDistanceValue != PilotingSettingsMaxDistanceValue_)
    {
      PilotingSettingsMaxDistanceValue_ = config.PilotingSettingsMaxDistanceValue;
      changed = true;
    }


    if (changed)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Sending PilotingSettingsMaxDistance changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsMaxDistance(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsMaxDistanceValue)
      );
    }

  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "PilotingSettingsMaxDistance::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);


    arg = NULL;
    // Manual edit, report the bug upstream
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_CURRENT, arg);
    if (arg)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsMaxDistanceValue exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsMaxDistanceValue"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsMaxDistanceValue", arg->value.Float);
        PilotingSettingsMaxDistanceValue_ = static_cast<double>(arg->value.Float);
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
      }
    }

  }

};  // PilotingSettingsMaxDistance


// 
class PilotingSettingsNoFlyOverMaxDistance : public AbstractSetting
{
private:
int32_t PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_;

public:

  PilotingSettingsNoFlyOverMaxDistance()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    bool changed = false;
    ::boost::lock_guard<boost::mutex> lock(mutex_);

    // This will likely fail for float or double values
    if (config.PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover != PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_)
    {
      PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_ = config.PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover;
      changed = true;
    }


    if (changed)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Sending PilotingSettingsNoFlyOverMaxDistance changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsNoFlyOverMaxDistance(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover)
      );
    }

  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "PilotingSettingsNoFlyOverMaxDistance::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED_SHOULDNOTFLYOVER, arg);
    if (arg)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover", arg->value.U8);
        PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_ = static_cast<int32_t>(arg->value.U8);
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
      }
    }

  }

};  // PilotingSettingsNoFlyOverMaxDistance


// 
class SpeedSettingsMaxVerticalSpeed : public AbstractSetting
{
private:
double SpeedSettingsMaxVerticalSpeedCurrent_;

public:

  SpeedSettingsMaxVerticalSpeed()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    bool changed = false;
    ::boost::lock_guard<boost::mutex> lock(mutex_);

    // This will likely fail for float or double values
    if (config.SpeedSettingsMaxVerticalSpeedCurrent != SpeedSettingsMaxVerticalSpeedCurrent_)
    {
      SpeedSettingsMaxVerticalSpeedCurrent_ = config.SpeedSettingsMaxVerticalSpeedCurrent;
      changed = true;
    }


    if (changed)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Sending SpeedSettingsMaxVerticalSpeed changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsMaxVerticalSpeed(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsMaxVerticalSpeedCurrent)
      );
    }

  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "SpeedSettingsMaxVerticalSpeed::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT, arg);
    if (arg)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if SpeedSettingsMaxVerticalSpeedCurrent exists in params ...");
      if (!priv_nh_.hasParam("SpeedSettingsMaxVerticalSpeedCurrent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("SpeedSettingsMaxVerticalSpeedCurrent", arg->value.Float);
        SpeedSettingsMaxVerticalSpeedCurrent_ = static_cast<double>(arg->value.Float);
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
      }
    }

  }

};  // SpeedSettingsMaxVerticalSpeed


// 
class SpeedSettingsMaxRotationSpeed : public AbstractSetting
{
private:
double SpeedSettingsMaxRotationSpeedCurrent_;

public:

  SpeedSettingsMaxRotationSpeed()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    bool changed = false;
    ::boost::lock_guard<boost::mutex> lock(mutex_);

    // This will likely fail for float or double values
    if (config.SpeedSettingsMaxRotationSpeedCurrent != SpeedSettingsMaxRotationSpeedCurrent_)
    {
      SpeedSettingsMaxRotationSpeedCurrent_ = config.SpeedSettingsMaxRotationSpeedCurrent;
      changed = true;
    }


    if (changed)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Sending SpeedSettingsMaxRotationSpeed changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsMaxRotationSpeed(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsMaxRotationSpeedCurrent)
      );
    }

  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "SpeedSettingsMaxRotationSpeed::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT, arg);
    if (arg)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if SpeedSettingsMaxRotationSpeedCurrent exists in params ...");
      if (!priv_nh_.hasParam("SpeedSettingsMaxRotationSpeedCurrent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("SpeedSettingsMaxRotationSpeedCurrent", arg->value.Float);
        SpeedSettingsMaxRotationSpeedCurrent_ = static_cast<double>(arg->value.Float);
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
      }
    }

  }

};  // SpeedSettingsMaxRotationSpeed


// 
class SpeedSettingsHullProtection : public AbstractSetting
{
private:
int32_t SpeedSettingsHullProtectionPresent_;

public:

  SpeedSettingsHullProtection()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    bool changed = false;
    ::boost::lock_guard<boost::mutex> lock(mutex_);

    // This will likely fail for float or double values
    if (config.SpeedSettingsHullProtectionPresent != SpeedSettingsHullProtectionPresent_)
    {
      SpeedSettingsHullProtectionPresent_ = config.SpeedSettingsHullProtectionPresent;
      changed = true;
    }


    if (changed)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Sending SpeedSettingsHullProtection changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsHullProtection(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsHullProtectionPresent)
      );
    }

  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "SpeedSettingsHullProtection::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED_PRESENT, arg);
    if (arg)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if SpeedSettingsHullProtectionPresent exists in params ...");
      if (!priv_nh_.hasParam("SpeedSettingsHullProtectionPresent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("SpeedSettingsHullProtectionPresent", arg->value.U8);
        SpeedSettingsHullProtectionPresent_ = static_cast<int32_t>(arg->value.U8);
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
      }
    }

  }

};  // SpeedSettingsHullProtection


// 
class SpeedSettingsOutdoor : public AbstractSetting
{
private:
int32_t SpeedSettingsOutdoorOutdoor_;

public:

  SpeedSettingsOutdoor()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    bool changed = false;
    ::boost::lock_guard<boost::mutex> lock(mutex_);

    // This will likely fail for float or double values
    if (config.SpeedSettingsOutdoorOutdoor != SpeedSettingsOutdoorOutdoor_)
    {
      SpeedSettingsOutdoorOutdoor_ = config.SpeedSettingsOutdoorOutdoor;
      changed = true;
    }


    if (changed)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Sending SpeedSettingsOutdoor changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsOutdoor(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsOutdoorOutdoor)
      );
    }

  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "SpeedSettingsOutdoor::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR, arg);
    if (arg)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if SpeedSettingsOutdoorOutdoor exists in params ...");
      if (!priv_nh_.hasParam("SpeedSettingsOutdoorOutdoor"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("SpeedSettingsOutdoorOutdoor", arg->value.U8);
        SpeedSettingsOutdoorOutdoor_ = static_cast<int32_t>(arg->value.U8);
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
      }
    }

  }

};  // SpeedSettingsOutdoor


// 
class NetworkSettingsWifiSelection : public AbstractSetting
{
private:
int32_t NetworkSettingsWifiSelectionType_;
int32_t NetworkSettingsWifiSelectionBand_;
int32_t NetworkSettingsWifiSelectionChannel_;

public:

  NetworkSettingsWifiSelection()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    bool changed = false;
    ::boost::lock_guard<boost::mutex> lock(mutex_);

    // This will likely fail for float or double values
    if (config.NetworkSettingsWifiSelectionType != NetworkSettingsWifiSelectionType_)
    {
      NetworkSettingsWifiSelectionType_ = config.NetworkSettingsWifiSelectionType;
      changed = true;
    }

    if (config.NetworkSettingsWifiSelectionBand != NetworkSettingsWifiSelectionBand_)
    {
      NetworkSettingsWifiSelectionBand_ = config.NetworkSettingsWifiSelectionBand;
      changed = true;
    }

    if (config.NetworkSettingsWifiSelectionChannel != NetworkSettingsWifiSelectionChannel_)
    {
      NetworkSettingsWifiSelectionChannel_ = config.NetworkSettingsWifiSelectionChannel;
      changed = true;
    }


    if (changed)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Sending NetworkSettingsWifiSelection changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendNetworkSettingsWifiSelection(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE>(config.NetworkSettingsWifiSelectionType)
        , static_cast<eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND>(config.NetworkSettingsWifiSelectionBand)
        , (config.NetworkSettingsWifiSelectionChannel)
      );
    }

  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "NetworkSettingsWifiSelection::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE, arg);
    if (arg)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if NetworkSettingsWifiSelectionType exists in params ...");
      if (!priv_nh_.hasParam("NetworkSettingsWifiSelectionType"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("NetworkSettingsWifiSelectionType", arg->value.U8);
        NetworkSettingsWifiSelectionType_ = static_cast<int32_t>(arg->value.U8);
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
      }
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND, arg);
    if (arg)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if NetworkSettingsWifiSelectionBand exists in params ...");
      if (!priv_nh_.hasParam("NetworkSettingsWifiSelectionBand"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("NetworkSettingsWifiSelectionBand", arg->value.U8);
        NetworkSettingsWifiSelectionBand_ = static_cast<int32_t>(arg->value.U8);
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
      }
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL, arg);
    if (arg)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if NetworkSettingsWifiSelectionChannel exists in params ...");
      if (!priv_nh_.hasParam("NetworkSettingsWifiSelectionChannel"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("NetworkSettingsWifiSelectionChannel", arg->value.U8);
        NetworkSettingsWifiSelectionChannel_ = static_cast<int32_t>(arg->value.U8);
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
      }
    }

  }

};  // NetworkSettingsWifiSelection


// 
class GPSSettingsHomeType : public AbstractSetting
{
private:
int32_t GPSSettingsHomeTypeType_;

public:

  GPSSettingsHomeType()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    bool changed = false;
    ::boost::lock_guard<boost::mutex> lock(mutex_);

    // This will likely fail for float or double values
    if (config.GPSSettingsHomeTypeType != GPSSettingsHomeTypeType_)
    {
      GPSSettingsHomeTypeType_ = config.GPSSettingsHomeTypeType;
      changed = true;
    }


    if (changed)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Sending GPSSettingsHomeType changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendGPSSettingsHomeType(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE>(config.GPSSettingsHomeTypeType)
      );
    }

  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "GPSSettingsHomeType::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE, arg);
    if (arg)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if GPSSettingsHomeTypeType exists in params ...");
      if (!priv_nh_.hasParam("GPSSettingsHomeTypeType"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("GPSSettingsHomeTypeType", arg->value.U8);
        GPSSettingsHomeTypeType_ = static_cast<int32_t>(arg->value.U8);
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
      }
    }

  }

};  // GPSSettingsHomeType


// 
class GPSSettingsReturnHomeDelay : public AbstractSetting
{
private:
int32_t GPSSettingsReturnHomeDelayDelay_;

public:

  GPSSettingsReturnHomeDelay()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    bool changed = false;
    ::boost::lock_guard<boost::mutex> lock(mutex_);

    // This will likely fail for float or double values
    if (config.GPSSettingsReturnHomeDelayDelay != GPSSettingsReturnHomeDelayDelay_)
    {
      GPSSettingsReturnHomeDelayDelay_ = config.GPSSettingsReturnHomeDelayDelay;
      changed = true;
    }


    if (changed)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Sending GPSSettingsReturnHomeDelay changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendGPSSettingsReturnHomeDelay(bebop_ctrl_ptr_->aRDrone3
        , (config.GPSSettingsReturnHomeDelayDelay)
      );
    }

  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "GPSSettingsReturnHomeDelay::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED_DELAY, arg);
    if (arg)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if GPSSettingsReturnHomeDelayDelay exists in params ...");
      if (!priv_nh_.hasParam("GPSSettingsReturnHomeDelayDelay"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("GPSSettingsReturnHomeDelayDelay", arg->value.U16);
        GPSSettingsReturnHomeDelayDelay_ = static_cast<int32_t>(arg->value.U16);
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
      }
    }

  }

};  // GPSSettingsReturnHomeDelay


}  // namespace cb
}  // namespace bebop_autonomy
#endif  // Ardrone3_SETTING_CALLBACKS_H
